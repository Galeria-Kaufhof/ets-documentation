{
    "docs": [
        {
            "location": "/",
            "text": "ETS Documentation - Start\n\n\nWhat is the ETS project?\n\n\nETS is a collection of components and practices which allow to build applications and libraries with Scala.\n\n\nIt is a software development framework and ecosystem consisting of:\n\n\n\n\n\n\nA strictly managed and reliably versioned Maven POM set which allows to build Scala libraries or applications where conflict-free interoperation of all ETS-covered external dependencies their transitive dependencies is guaranteed\n\n\n\n\n\n\nA collection of useful libraries built on top of this approach, which are guaranteed to work seamlessly with ETS-covered external dependencies and other ETS libraries\n\n\n\n\n\n\nA collection of Maven archetypes which allows to quickly bootstrap library or application projects that make use of the ETS ecosystem out-of-the-box.\n\n\n\n\n\n\nTable of contents\n\n\nGeneral documentation\n\n\n\n\nRules\n\n\nVersioning\n\n\n\n\nOfficial ETS libraries\n\n\n\n\nElasticSearch REST Connector: \nproject home\n, \ndocumentation\n\n\nSwift Object Store Adapter: \nproject home\n, \ndocumentation\n\n\nUtilities and Stages for Akka Streams: \nproject home\n, \ndocumentation\n\n\n\n\nETS ecosystem version registry and compatibility matrix\n\n\n\n\n\n\n\n\nETS version\n\n\n0\n\n\n1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nElasticSearch\n\n\n6.x\n\n\n\n\n\n\n\n\n\n\n\n\nCassandra\n\n\n2.x\n\n\n\n\n\n\n\n\n\n\n\n\nOpenStack Object Storage\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMeta information\n\n\nThis is the global documentation for the ETS version 0 release. See https://github.com/Galeria-Kaufhof/ets-documentation/tree/0.x.x for its source code.\n\n\nThere is no documentation for previous ETS releases.\n\n\nThe documentation for the upcoming ETS 1 release takes place at https://github.com/Galeria-Kaufhof/ets-documentation/tree/master.",
            "title": "ETS Documentation - Start"
        },
        {
            "location": "/#ets-documentation-start",
            "text": "",
            "title": "ETS Documentation - Start"
        },
        {
            "location": "/#what-is-the-ets-project",
            "text": "ETS is a collection of components and practices which allow to build applications and libraries with Scala.  It is a software development framework and ecosystem consisting of:    A strictly managed and reliably versioned Maven POM set which allows to build Scala libraries or applications where conflict-free interoperation of all ETS-covered external dependencies their transitive dependencies is guaranteed    A collection of useful libraries built on top of this approach, which are guaranteed to work seamlessly with ETS-covered external dependencies and other ETS libraries    A collection of Maven archetypes which allows to quickly bootstrap library or application projects that make use of the ETS ecosystem out-of-the-box.",
            "title": "What is the ETS project?"
        },
        {
            "location": "/#table-of-contents",
            "text": "",
            "title": "Table of contents"
        },
        {
            "location": "/#general-documentation",
            "text": "Rules  Versioning",
            "title": "General documentation"
        },
        {
            "location": "/#official-ets-libraries",
            "text": "ElasticSearch REST Connector:  project home ,  documentation  Swift Object Store Adapter:  project home ,  documentation  Utilities and Stages for Akka Streams:  project home ,  documentation",
            "title": "Official ETS libraries"
        },
        {
            "location": "/#ets-ecosystem-version-registry-and-compatibility-matrix",
            "text": "ETS version  0  1        ElasticSearch  6.x       Cassandra  2.x       OpenStack Object Storage",
            "title": "ETS ecosystem version registry and compatibility matrix"
        },
        {
            "location": "/#meta-information",
            "text": "This is the global documentation for the ETS version 0 release. See https://github.com/Galeria-Kaufhof/ets-documentation/tree/0.x.x for its source code.  There is no documentation for previous ETS releases.  The documentation for the upcoming ETS 1 release takes place at https://github.com/Galeria-Kaufhof/ets-documentation/tree/master.",
            "title": "Meta information"
        },
        {
            "location": "/archetypes/",
            "text": "",
            "title": "Archetypes"
        },
        {
            "location": "/architecture-and-philosophy/",
            "text": "Architecture and Philosophy\n\n\nArchitecture\n\n\nETS is not an artifact, it's an ecosystem\n\n\nThere is no such thing as an integrated and deployable \"ETS software\" artifact. Neither is it a software development framework.\n\n\nIt is an ecosystem of components that are developed under the same \nrules\n, the same \nversioning approach\n, and the same philosophy, which leads to a collection of artifacts that are guaranteed to play well together, and which can be used to build applications on top of them with a minimal amount of yak shaving. Additionally, the ecosystem provides helpers like our \narchetypes\n to boost development productivity even more.\n\n\nPhilosophy\n\n\nAlways stay near the cutting edge\n\n\nWe upgrade all external dependencies (including Scala and the JVM) to their most recent stable versions as soon as possible, keeping the ETS ecosystem compatible with the youngest iteration of the real world as soon as we can. While we do maintain previous ETS releases for a while, backwards-compatibility and long-term support of released versions is not our primary goal. We believe that this is better for a healthy and maintainable application landscape.",
            "title": "Architecture and Philosophy"
        },
        {
            "location": "/architecture-and-philosophy/#architecture-and-philosophy",
            "text": "",
            "title": "Architecture and Philosophy"
        },
        {
            "location": "/architecture-and-philosophy/#architecture",
            "text": "",
            "title": "Architecture"
        },
        {
            "location": "/architecture-and-philosophy/#ets-is-not-an-artifact-its-an-ecosystem",
            "text": "There is no such thing as an integrated and deployable \"ETS software\" artifact. Neither is it a software development framework.  It is an ecosystem of components that are developed under the same  rules , the same  versioning approach , and the same philosophy, which leads to a collection of artifacts that are guaranteed to play well together, and which can be used to build applications on top of them with a minimal amount of yak shaving. Additionally, the ecosystem provides helpers like our  archetypes  to boost development productivity even more.",
            "title": "ETS is not an artifact, it's an ecosystem"
        },
        {
            "location": "/architecture-and-philosophy/#philosophy",
            "text": "",
            "title": "Philosophy"
        },
        {
            "location": "/architecture-and-philosophy/#always-stay-near-the-cutting-edge",
            "text": "We upgrade all external dependencies (including Scala and the JVM) to their most recent stable versions as soon as possible, keeping the ETS ecosystem compatible with the youngest iteration of the real world as soon as we can. While we do maintain previous ETS releases for a while, backwards-compatibility and long-term support of released versions is not our primary goal. We believe that this is better for a healthy and maintainable application landscape.",
            "title": "Always stay near the cutting edge"
        },
        {
            "location": "/building-libraries/",
            "text": "",
            "title": "Building libraries"
        },
        {
            "location": "/building-services/",
            "text": "",
            "title": "Building services"
        },
        {
            "location": "/releasing/",
            "text": "",
            "title": "Releasing"
        },
        {
            "location": "/rules/",
            "text": "Rules\n\n\nThis document describes the code, architecture, and lifecycle rules that are obligatory for all ETS components.\n\n\nGeneral rules\n\n\n\n\n\n\nAll public ETS component code repositories have their home at \nhttps://github.com/Galeria-Kaufhof/ets-<name-of-component>\n\n\n\n\n\n\nAll ETS components that release and publish artifacts used by others must follow the \nSemantic Versioning 2.0.0 guidelines\n for versioning their releases\n\n\n\n\n\n\nAll public ETS components must ship with a root folder \nCHANGELOG.md\n file that follows the \nKeep a Changelog 1.0.0\n guidelines\n\n\n\n\n\n\nAll public ETS components must be released under \nThe MIT License\n and must be copyright Galeria Kaufhof GmbH if released by Galeria Kaufhof GmbH employees or contractors\n\n\n\n\n\n\nNaming and namespacing rules\n\n\n\n\n\n\nETS Software uses the Java namespace \nde.kaufhof.ets\n\n\n\n\n\n\nWithin this namespace, each component has its own namespace/artifactId e.g. \nfilestorage\n, resulting in the fully qualified namespace \nde.kaufhof.ets.filestorage\n \n\n\n\n\n\n\nWithin a component's namespace, each subcomponent has its own namespace/artifactId e.g. \ncore\n, resulting in the fully qualified namespace \nde.kaufhof.ets.filestorage.core\n \n\n\n\n\n\n\nThe id of all artifacts an ETS component releases must start with \nets-\n, e.g. \nets-library-parent\n\n\n\n\n\n\nIf your component is an ETS library or application, then if it has only one subcomponent, its artifactId must end with \n-core\n, e.g. \nets-filestorage-core\n; additional subcomponents can have arbitrary artifactId endings, e.g. \nets-filestorage-nfs\n\n\n\n\n\n\nSubcomponents of an ETS component must live in root subfolders which are named like the subcomponent's artifactId, e.g. \n/ets-filestorage-core\n\n\n\n\n\n\nWithin a subcomponent's subfolder, create a source code hierarchy following the pattern \nsrc/main/scala/de/kaufhof/ets/<component-name>/<subcomponent-name>\n, e.g. \nsrc/main/scala/de/kaufhof/ets/filestorage/core\n\n\n\n\n\n\nComponent and subcomponent names must be one-word all-lowercase UTF-8 \n[a-z0-9]\n strings",
            "title": "Rules"
        },
        {
            "location": "/rules/#rules",
            "text": "This document describes the code, architecture, and lifecycle rules that are obligatory for all ETS components.",
            "title": "Rules"
        },
        {
            "location": "/rules/#general-rules",
            "text": "All public ETS component code repositories have their home at  https://github.com/Galeria-Kaufhof/ets-<name-of-component>    All ETS components that release and publish artifacts used by others must follow the  Semantic Versioning 2.0.0 guidelines  for versioning their releases    All public ETS components must ship with a root folder  CHANGELOG.md  file that follows the  Keep a Changelog 1.0.0  guidelines    All public ETS components must be released under  The MIT License  and must be copyright Galeria Kaufhof GmbH if released by Galeria Kaufhof GmbH employees or contractors",
            "title": "General rules"
        },
        {
            "location": "/rules/#naming-and-namespacing-rules",
            "text": "ETS Software uses the Java namespace  de.kaufhof.ets    Within this namespace, each component has its own namespace/artifactId e.g.  filestorage , resulting in the fully qualified namespace  de.kaufhof.ets.filestorage      Within a component's namespace, each subcomponent has its own namespace/artifactId e.g.  core , resulting in the fully qualified namespace  de.kaufhof.ets.filestorage.core      The id of all artifacts an ETS component releases must start with  ets- , e.g.  ets-library-parent    If your component is an ETS library or application, then if it has only one subcomponent, its artifactId must end with  -core , e.g.  ets-filestorage-core ; additional subcomponents can have arbitrary artifactId endings, e.g.  ets-filestorage-nfs    Subcomponents of an ETS component must live in root subfolders which are named like the subcomponent's artifactId, e.g.  /ets-filestorage-core    Within a subcomponent's subfolder, create a source code hierarchy following the pattern  src/main/scala/de/kaufhof/ets/<component-name>/<subcomponent-name> , e.g.  src/main/scala/de/kaufhof/ets/filestorage/core    Component and subcomponent names must be one-word all-lowercase UTF-8  [a-z0-9]  strings",
            "title": "Naming and namespacing rules"
        },
        {
            "location": "/versioning/",
            "text": "Versioning\n\n\nThis document describes how different versions of ETS component source codes and artifacts are managed, declared, structured and used within the development and release lifecycles of a component.\n\n\nETS core and components versioning relationships\n\n\nWhile there is no single central \"ETS application\" which is maintained and released in an integrated and central fashion, we nevertheless handle the offical ETS ecosystem as one connected construct, and version accordingly.\n\n\nTo do so, we define major ETS releases following the SemVer schema, thus subsuming ETS core components and ETS libraries under the same major version number for each release.\n\n\nThe result is a collection of components with publicly artifacts, where artifacts that share the same major version number are guaranteed to be compatible with each other.\n\n\nThus, for example, the \"ETS version 1 release\" is the collection of all 1.x.x versions of the different ETS components.\n\n\nBecause there is no central ETS artifact, releases of the general ETS ecosystem are not specified using a \nmajor.minor.patch\n schema. Instead, the concrete state of an \"ETS version 1 release\" is in constant flux - at a given point in time, it could be a collection of \nets-elasticsearch-rest-connector 1.4.3\n, \nets-filestorage 1.2.0\n, and \nets-akka-stream-utils 1.9.5\n, and choosing from a subset of these components as a basis for your \"ETS version 1\"-based application is legit and safe in terms of interoperability of the components - as long as you don't \"pin\" your dependency definitions to a specific version of an ETS component, and instead use a range definition (\n[1.0.0,2)\n).\n\n\nGit branching and tagging\n\n\nAll ETS component git repositories follow these rules:\n\n\n\n\nAs soon as the first major non-0.x.x version of a component is released, the git repository must have a tag named \n<current-major>.0.0\n which points to the commit with which the release milestone was reached\n\n\nAs soon as the first major non-0.x.x version of a component is released, the git repository must have a branch named \n<current-major>.x.x\n whose tip points to the latest version of the code within the current major version\n\n\nWhenever new minor/patch versions are released within a major release, \n<major>.<minor>.<patch>\n tags must be created accordingly\n\n\nThe latest version of the upcoming but not yet released minor/patch version of a released major version is developed in the \n<major>.x.x\n branch\n\n\nMeanwhile, the latest version of the upcoming but not yet released \n<current-major + 1>\n version of the component is developed in the \nmaster\n branch\n\n\nAs soon as a new major version (= \n<current-major + 1>\n) is released, a tag named \n<current-major + 1>.0.0\n and a new branch \n<current-major + 1>.0.0\n must be created\n\n\nThus, \n<current-major + 1>\n becomes the new \n<current-major>\n\n\nAgain, the latest version of the upcoming but not yet released \n<current-major+1>\n version of the component is developed in the \nmaster\n branch\n\n\n\n\nExample:\n\n\nLet's assume that ETS has already been released in versions \n1\n and \n2\n, and work on a version \n3\n release is ongoing. In this case, the git branch and tag structure of a hypothetical ETS component \nets-foo-connector\n might look as follows:\n\n\n\n\nA branch \nmaster\n exists, containing the current work that is underway to prepare release \nets-foo-connector 3.0.0\n for the upcoming ETS version 3 release\n\n\nA branch \n1.x.x\n exists, because \nets-foo-connector\n was part of the ETS version 1 release; it contains the latest code for this major version, up to and including a couple of not-yet-released changes for a bugfix that will be released as \nets-foo-connector 1.2.1\n\n\nThe tags \n1.0.0\n, \n1.2.0\n, and \n1.3.0\n exist. They all point to commits that are also included within the commit history of branch \n1.x.x\n, and mark the different minor versions that this component released within the ETS version 1 release\n\n\nA branch \n2.x.x\n exists, because \nets-foo-connector\n was part of the ETS version 2 release\n\n\nOnly the tag \n2.0.0\n exists, because after the initial 2.x.x release, the project did not release any new versions under the ETS version 2 release",
            "title": "Versioning"
        },
        {
            "location": "/versioning/#versioning",
            "text": "This document describes how different versions of ETS component source codes and artifacts are managed, declared, structured and used within the development and release lifecycles of a component.",
            "title": "Versioning"
        },
        {
            "location": "/versioning/#ets-core-and-components-versioning-relationships",
            "text": "While there is no single central \"ETS application\" which is maintained and released in an integrated and central fashion, we nevertheless handle the offical ETS ecosystem as one connected construct, and version accordingly.  To do so, we define major ETS releases following the SemVer schema, thus subsuming ETS core components and ETS libraries under the same major version number for each release.  The result is a collection of components with publicly artifacts, where artifacts that share the same major version number are guaranteed to be compatible with each other.  Thus, for example, the \"ETS version 1 release\" is the collection of all 1.x.x versions of the different ETS components.  Because there is no central ETS artifact, releases of the general ETS ecosystem are not specified using a  major.minor.patch  schema. Instead, the concrete state of an \"ETS version 1 release\" is in constant flux - at a given point in time, it could be a collection of  ets-elasticsearch-rest-connector 1.4.3 ,  ets-filestorage 1.2.0 , and  ets-akka-stream-utils 1.9.5 , and choosing from a subset of these components as a basis for your \"ETS version 1\"-based application is legit and safe in terms of interoperability of the components - as long as you don't \"pin\" your dependency definitions to a specific version of an ETS component, and instead use a range definition ( [1.0.0,2) ).",
            "title": "ETS core and components versioning relationships"
        },
        {
            "location": "/versioning/#git-branching-and-tagging",
            "text": "All ETS component git repositories follow these rules:   As soon as the first major non-0.x.x version of a component is released, the git repository must have a tag named  <current-major>.0.0  which points to the commit with which the release milestone was reached  As soon as the first major non-0.x.x version of a component is released, the git repository must have a branch named  <current-major>.x.x  whose tip points to the latest version of the code within the current major version  Whenever new minor/patch versions are released within a major release,  <major>.<minor>.<patch>  tags must be created accordingly  The latest version of the upcoming but not yet released minor/patch version of a released major version is developed in the  <major>.x.x  branch  Meanwhile, the latest version of the upcoming but not yet released  <current-major + 1>  version of the component is developed in the  master  branch  As soon as a new major version (=  <current-major + 1> ) is released, a tag named  <current-major + 1>.0.0  and a new branch  <current-major + 1>.0.0  must be created  Thus,  <current-major + 1>  becomes the new  <current-major>  Again, the latest version of the upcoming but not yet released  <current-major+1>  version of the component is developed in the  master  branch",
            "title": "Git branching and tagging"
        },
        {
            "location": "/versioning/#example",
            "text": "Let's assume that ETS has already been released in versions  1  and  2 , and work on a version  3  release is ongoing. In this case, the git branch and tag structure of a hypothetical ETS component  ets-foo-connector  might look as follows:   A branch  master  exists, containing the current work that is underway to prepare release  ets-foo-connector 3.0.0  for the upcoming ETS version 3 release  A branch  1.x.x  exists, because  ets-foo-connector  was part of the ETS version 1 release; it contains the latest code for this major version, up to and including a couple of not-yet-released changes for a bugfix that will be released as  ets-foo-connector 1.2.1  The tags  1.0.0 ,  1.2.0 , and  1.3.0  exist. They all point to commits that are also included within the commit history of branch  1.x.x , and mark the different minor versions that this component released within the ETS version 1 release  A branch  2.x.x  exists, because  ets-foo-connector  was part of the ETS version 2 release  Only the tag  2.0.0  exists, because after the initial 2.x.x release, the project did not release any new versions under the ETS version 2 release",
            "title": "Example:"
        },
        {
            "location": "/libraries/Akka-Stream-Utils/",
            "text": "",
            "title": "Home"
        },
        {
            "location": "/libraries/ElasticSearch-REST-Connector/",
            "text": "ElasticSearch REST Connector\n\n\nTable of contents\n\n\n\n\nIndexing",
            "title": "ElasticSearch REST Connector"
        },
        {
            "location": "/libraries/ElasticSearch-REST-Connector/#elasticsearch-rest-connector",
            "text": "",
            "title": "ElasticSearch REST Connector"
        },
        {
            "location": "/libraries/ElasticSearch-REST-Connector/#table-of-contents",
            "text": "Indexing",
            "title": "Table of contents"
        },
        {
            "location": "/libraries/ElasticSearch-REST-Connector/indexing/",
            "text": "Indexing\n\n\nCreate an index\n\n\nBased on this documentation. For now, it is only implemented that you can create an index with a \nMappingobject\n or a \nJson-Object\n.\n\n\nelasticClient.createIndex(INDEXNAME, MAPPINGOBJECT): Future[ElasticIndexCreateResult]\n\n\n\nEach \ncreateIndex\n resulted in a \nscala.concurrent.Future[ElasticIndexCreateResult]\n with the following \nReturnParameter\n:\n\n\nElasticIndexCreateResult.created[Boolean]\nElasticIndexCreateResult.throwable[Option[Throwable]]\n\n\n\nIf the \ncreateIndex\n resulted without errors, \n.throwable\n is \nNone\n, if not, \n.throwable\n is filled as \nSome(throwable)\n with the underlying exception.",
            "title": "Indexing"
        },
        {
            "location": "/libraries/ElasticSearch-REST-Connector/indexing/#indexing",
            "text": "",
            "title": "Indexing"
        },
        {
            "location": "/libraries/ElasticSearch-REST-Connector/indexing/#create-an-index",
            "text": "Based on this documentation. For now, it is only implemented that you can create an index with a  Mappingobject  or a  Json-Object .  elasticClient.createIndex(INDEXNAME, MAPPINGOBJECT): Future[ElasticIndexCreateResult]  Each  createIndex  resulted in a  scala.concurrent.Future[ElasticIndexCreateResult]  with the following  ReturnParameter :  ElasticIndexCreateResult.created[Boolean]\nElasticIndexCreateResult.throwable[Option[Throwable]]  If the  createIndex  resulted without errors,  .throwable  is  None , if not,  .throwable  is filled as  Some(throwable)  with the underlying exception.",
            "title": "Create an index"
        },
        {
            "location": "/libraries/Filestorage/",
            "text": "",
            "title": "Home"
        }
    ]
}