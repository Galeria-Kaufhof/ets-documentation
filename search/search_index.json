{
    "docs": [
        {
            "location": "/",
            "text": "ETS Documentation - Start\n\n\nWhat is the ETS project?\n\n\nETS is a collection of components and practices which allow to build applications and libraries with Scala.\n\n\nIt is a software development framework and ecosystem consisting of:\n\n\n\n\n\n\nA strictly managed and reliably versioned Maven POM set which allows to build Scala libraries or applications where conflict-free interoperation of all ETS-covered external dependencies their transitive dependencies is guaranteed\n\n\n\n\n\n\nA collection of useful libraries built on top of this approach, which are guaranteed to work seamlessly with ETS-covered external dependencies and other ETS libraries\n\n\n\n\n\n\nA collection of Maven archetypes which allows to quickly bootstrap library or application projects that make use of the ETS ecosystem out-of-the-box.\n\n\n\n\n\n\nTable of contents\n\n\nGeneral documentation\n\n\n\n\nArchitecture & philosophy\n\n\n\n\nDocumentation for maintainers\n\n\nThese documents support those that extend and maintain ETS components.\n\n\n\n\nRules\n\n\nVersioning\n\n\nContributing\n\n\n\n\nETS ecosystem overview\n\n\nVersion overview\n\n\n\n\n\n\n\n\nETS version\n\n\nLifecycle status\n\n\n\n\n\n\n\n\n\n\n0\n\n\nUpcoming\n\n\n\n\n\n\n\n\nManaged external dependencies\n\n\n\n\n\n\n\n\nETS version\n\n\n0\n\n\n\n\n\n\n\n\n\n\nElasticSearch\n\n\n6.x\n\n\n\n\n\n\nCassandra\n\n\n2.x\n\n\n\n\n\n\nPostgres\n\n\n9.6\n\n\n\n\n\n\nOpenStack Object Storage\n\n\n\n\n\n\n\n\n\n\nETS library availability\n\n\n\n\n\n\n\n\nETS version\n\n\n0\n\n\n\n\n\n\n\n\n\n\nFilestorage\n\n\ncode\n,                  \ndocs\n\n\n\n\n\n\nAkka Stream Utils\n\n\ncode\n,            \ndocs\n\n\n\n\n\n\nElasticSearch REST Connector\n\n\ncode\n, \ndocs\n\n\n\n\n\n\n\n\nMeta information\n\n\nThis is the global documentation for the ETS version 0 release. See https://github.com/Galeria-Kaufhof/ets-documentation/tree/0.x.x for its source code.\n\n\nThere is no documentation for previous ETS releases.",
            "title": "ETS Documentation - Start"
        },
        {
            "location": "/#ets-documentation-start",
            "text": "",
            "title": "ETS Documentation - Start"
        },
        {
            "location": "/#what-is-the-ets-project",
            "text": "ETS is a collection of components and practices which allow to build applications and libraries with Scala.  It is a software development framework and ecosystem consisting of:    A strictly managed and reliably versioned Maven POM set which allows to build Scala libraries or applications where conflict-free interoperation of all ETS-covered external dependencies their transitive dependencies is guaranteed    A collection of useful libraries built on top of this approach, which are guaranteed to work seamlessly with ETS-covered external dependencies and other ETS libraries    A collection of Maven archetypes which allows to quickly bootstrap library or application projects that make use of the ETS ecosystem out-of-the-box.",
            "title": "What is the ETS project?"
        },
        {
            "location": "/#table-of-contents",
            "text": "",
            "title": "Table of contents"
        },
        {
            "location": "/#general-documentation",
            "text": "Architecture & philosophy",
            "title": "General documentation"
        },
        {
            "location": "/#documentation-for-maintainers",
            "text": "These documents support those that extend and maintain ETS components.   Rules  Versioning  Contributing",
            "title": "Documentation for maintainers"
        },
        {
            "location": "/#ets-ecosystem-overview",
            "text": "",
            "title": "ETS ecosystem overview"
        },
        {
            "location": "/#version-overview",
            "text": "ETS version  Lifecycle status      0  Upcoming",
            "title": "Version overview"
        },
        {
            "location": "/#managed-external-dependencies",
            "text": "ETS version  0      ElasticSearch  6.x    Cassandra  2.x    Postgres  9.6    OpenStack Object Storage",
            "title": "Managed external dependencies"
        },
        {
            "location": "/#ets-library-availability",
            "text": "ETS version  0      Filestorage  code ,                   docs    Akka Stream Utils  code ,             docs    ElasticSearch REST Connector  code ,  docs",
            "title": "ETS library availability"
        },
        {
            "location": "/#meta-information",
            "text": "This is the global documentation for the ETS version 0 release. See https://github.com/Galeria-Kaufhof/ets-documentation/tree/0.x.x for its source code.  There is no documentation for previous ETS releases.",
            "title": "Meta information"
        },
        {
            "location": "/architecture-and-philosophy/",
            "text": "Architecture and Philosophy\n\n\nArchitecture\n\n\nETS is not a framework, it's an opinionated ecosystem\n\n\nThere is no such thing as an integrated and deployable \"ETS software\" artifact. Neither is it a software development framework.\n\n\nIt is an ecosystem of components that are developed under the same \nrules\n, the same \nversioning approach\n, and the same philosophy, which leads to a collection of artifacts that are guaranteed to play well together, and which can be used to build applications on top of them with a minimal amount of yak shaving. Additionally, the ecosystem provides helpers like our \narchetypes\n to boost development productivity even more.\n\n\nPhilosophy\n\n\nAlways stay near the cutting edge\n\n\nWe upgrade all external dependencies (including Scala and the JVM) to their most recent stable versions as soon as possible, keeping the ETS ecosystem compatible with the youngest iteration of the real world as soon as we can. While we do maintain previous ETS releases for a while, backwards-compatibility and long-term support of released versions is not our primary goal. We believe that this is better for a healthy and maintainable application landscape.",
            "title": "Architecture and Philosophy"
        },
        {
            "location": "/architecture-and-philosophy/#architecture-and-philosophy",
            "text": "",
            "title": "Architecture and Philosophy"
        },
        {
            "location": "/architecture-and-philosophy/#architecture",
            "text": "",
            "title": "Architecture"
        },
        {
            "location": "/architecture-and-philosophy/#ets-is-not-a-framework-its-an-opinionated-ecosystem",
            "text": "There is no such thing as an integrated and deployable \"ETS software\" artifact. Neither is it a software development framework.  It is an ecosystem of components that are developed under the same  rules , the same  versioning approach , and the same philosophy, which leads to a collection of artifacts that are guaranteed to play well together, and which can be used to build applications on top of them with a minimal amount of yak shaving. Additionally, the ecosystem provides helpers like our  archetypes  to boost development productivity even more.",
            "title": "ETS is not a framework, it's an opinionated ecosystem"
        },
        {
            "location": "/architecture-and-philosophy/#philosophy",
            "text": "",
            "title": "Philosophy"
        },
        {
            "location": "/architecture-and-philosophy/#always-stay-near-the-cutting-edge",
            "text": "We upgrade all external dependencies (including Scala and the JVM) to their most recent stable versions as soon as possible, keeping the ETS ecosystem compatible with the youngest iteration of the real world as soon as we can. While we do maintain previous ETS releases for a while, backwards-compatibility and long-term support of released versions is not our primary goal. We believe that this is better for a healthy and maintainable application landscape.",
            "title": "Always stay near the cutting edge"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/building-libraries/",
            "text": "",
            "title": "Building libraries"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/contributing/",
            "text": "Contributing\n\n\nGeneral rules and workflow\n\n\nNote: read \"ETS version\" and \"ETS release\" as \"version of the ETS component you want to contribute to\" and \"release of the ETS component you want to contribute to\". We use the short form here to save bytes.\n\n\n\n\nEven if you have write access to an ETS component repository, always work in a branch to contribute changes\n\n\nOnly release managers may push changes into the \nmaster\n branch and the \n<major>.x.x\n branches, and may do so only for release related tasks\n\n\nIf you want your change to become part of an upcoming ETS release (with possible backporting to already released ETS versions), then branch from \nmaster\n, and make the PR against \nmaster\n\n\nIf you want your changes to be applied to one or more already released ETS versions, but not to the upcoming release, then branch from the \n<major>.x.x\n branch of the \nlowest\n ETS version you want to apply your changes to, and make the PR against this branch\n\n\nYou can open a PR for your changes as soon as you have opened a branch for the changes, even while your branch is still work in progress. However, in this case the PR title must be prefixed with \nWIP:\n\n\nAlternatively, open the PR only once your branch is ready to be merged\n\n\nforce-push on your branch is permitted\n\n\nDuring development, rebase at least once, and do so the moment before offering the PR for merging\n\n\nIt is recommended to rebase your branch whenever there is a change in the master\n\n\nContribute accompanying documentation changes to the \nets-documentation\n repository the same way that you contribute your code changes to the ETS component repository - all of the above rules apply; this means if your code changes demand documentation changes, you must also create a branch and PR on the \nets-documentation\n repository, and your code PR description must reference your documentation PR\n\n\n\n\nHow contributions are integrated\n\n\nFor each contribution, the release manager must decide if the contribution shall only be integrated into the upcoming major ETS release, or if it should also be backported to already released ETS versions. \n\n\nWithout backporting\n\n\n\n\nThe pull request is merged into the master, and the commit message of the merge must contain \ncloses: #<id-of-pr>\n\n\n\n\nWith backporting\n\n\n\n\nDecide on the lowest ETS version to which the changes shall be backported (\"lowest target\")\n\n\nFetch the branch containing the changes (\"source branch\")\n\n\nCheckout the \n<major>.x.x\n branch of the ETS component, where \n<major>\n is the lowest ETS version you chose (\"target branch\")\n\n\nCherry-pick the commits of the source branch into the target branch, add \ncloses #<id-of-pr>\n to the commit message\n\n\nFor each ETS version larger than the lowest target, check out out its \n<major>.x.x\n branch, which becomes the new \"target branch\", and merge the previous target branch into it (e.g. \ngit checkout 2.x.x; git merge 1.x.x\n) - this must happen in order, from lowest to largest major version\n\n\nConflicts during merge must be handled as follows:\n\n\nIf conflicts arise in \npom.xml\n files, simply roll back the changes introduced by the merge on these files\n\n\nHandle new files which are introduced as a conflict that must be manually solved: if these files are not required on this particular version, they must be removed\n\n\nHandle other conflicts as usual\n\n\nCommit the merge result, and continue with the next major version branch, if any\n\n\nIf no major version branches are \"left\", and the changes must become part of the upcoming ETS release, merge the \n<major>.x.x\n branch with the largest major version into \nmaster\n\n\nFinally, push all changed branches\n\n\n\n\nIt is important to note that we \nalways\n need to merge each PR all the way up to \nmaster\n, even if this results in empty changesets for \"higher\" version branches and/or \nmaster\n. This guarantees that a PR which only applies to e.g. \n1.x.x\n that is followed by a PR which applies to \n1.x.x\n and \n2.x.x\n and \nmaster\n doesn't need to be handled when merging the latter PR.",
            "title": "Contributing"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/contributing/#contributing",
            "text": "",
            "title": "Contributing"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/contributing/#general-rules-and-workflow",
            "text": "Note: read \"ETS version\" and \"ETS release\" as \"version of the ETS component you want to contribute to\" and \"release of the ETS component you want to contribute to\". We use the short form here to save bytes.   Even if you have write access to an ETS component repository, always work in a branch to contribute changes  Only release managers may push changes into the  master  branch and the  <major>.x.x  branches, and may do so only for release related tasks  If you want your change to become part of an upcoming ETS release (with possible backporting to already released ETS versions), then branch from  master , and make the PR against  master  If you want your changes to be applied to one or more already released ETS versions, but not to the upcoming release, then branch from the  <major>.x.x  branch of the  lowest  ETS version you want to apply your changes to, and make the PR against this branch  You can open a PR for your changes as soon as you have opened a branch for the changes, even while your branch is still work in progress. However, in this case the PR title must be prefixed with  WIP:  Alternatively, open the PR only once your branch is ready to be merged  force-push on your branch is permitted  During development, rebase at least once, and do so the moment before offering the PR for merging  It is recommended to rebase your branch whenever there is a change in the master  Contribute accompanying documentation changes to the  ets-documentation  repository the same way that you contribute your code changes to the ETS component repository - all of the above rules apply; this means if your code changes demand documentation changes, you must also create a branch and PR on the  ets-documentation  repository, and your code PR description must reference your documentation PR",
            "title": "General rules and workflow"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/contributing/#how-contributions-are-integrated",
            "text": "For each contribution, the release manager must decide if the contribution shall only be integrated into the upcoming major ETS release, or if it should also be backported to already released ETS versions.",
            "title": "How contributions are integrated"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/contributing/#without-backporting",
            "text": "The pull request is merged into the master, and the commit message of the merge must contain  closes: #<id-of-pr>",
            "title": "Without backporting"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/contributing/#with-backporting",
            "text": "Decide on the lowest ETS version to which the changes shall be backported (\"lowest target\")  Fetch the branch containing the changes (\"source branch\")  Checkout the  <major>.x.x  branch of the ETS component, where  <major>  is the lowest ETS version you chose (\"target branch\")  Cherry-pick the commits of the source branch into the target branch, add  closes #<id-of-pr>  to the commit message  For each ETS version larger than the lowest target, check out out its  <major>.x.x  branch, which becomes the new \"target branch\", and merge the previous target branch into it (e.g.  git checkout 2.x.x; git merge 1.x.x ) - this must happen in order, from lowest to largest major version  Conflicts during merge must be handled as follows:  If conflicts arise in  pom.xml  files, simply roll back the changes introduced by the merge on these files  Handle new files which are introduced as a conflict that must be manually solved: if these files are not required on this particular version, they must be removed  Handle other conflicts as usual  Commit the merge result, and continue with the next major version branch, if any  If no major version branches are \"left\", and the changes must become part of the upcoming ETS release, merge the  <major>.x.x  branch with the largest major version into  master  Finally, push all changed branches   It is important to note that we  always  need to merge each PR all the way up to  master , even if this results in empty changesets for \"higher\" version branches and/or  master . This guarantees that a PR which only applies to e.g.  1.x.x  that is followed by a PR which applies to  1.x.x  and  2.x.x  and  master  doesn't need to be handled when merging the latter PR.",
            "title": "With backporting"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/releasing/",
            "text": "",
            "title": "Releasing"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/rules/",
            "text": "Rules\n\n\nThis document describes the code, architecture, and lifecycle rules that are obligatory for all ETS components.\n\n\nGeneral rules\n\n\n\n\n\n\nAll public ETS component code repositories have their home at \nhttps://github.com/Galeria-Kaufhof/ets-<name-of-component>\n\n\n\n\n\n\nAll ETS components that release and publish artifacts used by others must follow the \nSemantic Versioning 2.0.0 guidelines\n for versioning their releases\n\n\n\n\n\n\nAll public ETS components must ship with a root folder \nCHANGELOG.md\n file that follows the \nKeep a Changelog 1.0.0\n guidelines\n\n\n\n\n\n\nAll public ETS components must be released under \nThe MIT License\n and must be copyright Galeria Kaufhof GmbH if released by Galeria Kaufhof GmbH employees or contractors\n\n\n\n\n\n\nNaming and namespacing rules\n\n\n\n\n\n\nThe correct spelling of the long form name of ETS is \nGaleria Kaufhof eShop Technology Stack\n, the correct spelling of the medium form name is \neShop Technology Stack\n, and the short form is \nETS\n\n\n\n\n\n\nETS Software uses the Java namespace / groupId \nde.kaufhof.ets\n\n\n\n\n\n\nWithin this namespace, each component has its own namespace, e.g. \nfilestorage\n, resulting in the fully qualified namespace \nde.kaufhof.ets.filestorage\n \n\n\n\n\n\n\nWithin a component's namespace, each subcomponent has its own namespace, e.g. \ncore\n, resulting in the fully qualified namespace \nde.kaufhof.ets.filestorage.core\n \n\n\n\n\n\n\nThe artifactId of all artifacts an ETS component releases must start with \nets-\n, e.g. \nets-filestorage-core\n\n\n\n\n\n\nIf your component is an ETS library or application, then if it has only one subcomponent, its artifactId must end with \n-core\n, e.g. \nets-filestorage-core\n; additional subcomponents can have arbitrary artifactId endings, e.g. \nets-filestorage-nfs\n\n\n\n\n\n\nSubcomponents of an ETS component must live in root subfolders which are named like the subcomponent's artifactId, e.g. \n/ets-filestorage-core\n\n\n\n\n\n\nWithin a subcomponent's subfolder, create a source code hierarchy following the pattern \nsrc/main/scala/de/kaufhof/ets/<component-name>/<subcomponent-name>\n, e.g. \nsrc/main/scala/de/kaufhof/ets/filestorage/core\n\n\n\n\n\n\nComponent and subcomponent namespace segments must be one-word all-lowercase UTF-8 \n[a-z0-9]\n strings (e.g. \nde.kaufhof.ets.filestorage.core\n)\n\n\n\n\n\n\nComponent artifactIds must be at-least-one-word, possibly multiple-words-concatenated-by-hyphens all-lowercase UTF-8 \n[a-z0-9]\n strings (e.g. \nets-filestorage-core\n)\n\n\n\n\n\n\nExample\n\n\nThe source code for an ETS-compatible filestorage library would live at \nhttps://github.com/Galeria-Kaufhof/ets-filestorage\n.\n\n\nIts groupId + artifactId name would be \nde.kaufhof.ets:ets-filestorage-core\n.\n\n\nThe Scala source code tree starts at \n/ets-filestorage-core/src/main/scala/de/kaufhof/ets/filestorage/core\n, with package names starting with \nde.kaufhof.ets.filestorage.core\n.",
            "title": "Rules"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/rules/#rules",
            "text": "This document describes the code, architecture, and lifecycle rules that are obligatory for all ETS components.",
            "title": "Rules"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/rules/#general-rules",
            "text": "All public ETS component code repositories have their home at  https://github.com/Galeria-Kaufhof/ets-<name-of-component>    All ETS components that release and publish artifacts used by others must follow the  Semantic Versioning 2.0.0 guidelines  for versioning their releases    All public ETS components must ship with a root folder  CHANGELOG.md  file that follows the  Keep a Changelog 1.0.0  guidelines    All public ETS components must be released under  The MIT License  and must be copyright Galeria Kaufhof GmbH if released by Galeria Kaufhof GmbH employees or contractors",
            "title": "General rules"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/rules/#naming-and-namespacing-rules",
            "text": "The correct spelling of the long form name of ETS is  Galeria Kaufhof eShop Technology Stack , the correct spelling of the medium form name is  eShop Technology Stack , and the short form is  ETS    ETS Software uses the Java namespace / groupId  de.kaufhof.ets    Within this namespace, each component has its own namespace, e.g.  filestorage , resulting in the fully qualified namespace  de.kaufhof.ets.filestorage      Within a component's namespace, each subcomponent has its own namespace, e.g.  core , resulting in the fully qualified namespace  de.kaufhof.ets.filestorage.core      The artifactId of all artifacts an ETS component releases must start with  ets- , e.g.  ets-filestorage-core    If your component is an ETS library or application, then if it has only one subcomponent, its artifactId must end with  -core , e.g.  ets-filestorage-core ; additional subcomponents can have arbitrary artifactId endings, e.g.  ets-filestorage-nfs    Subcomponents of an ETS component must live in root subfolders which are named like the subcomponent's artifactId, e.g.  /ets-filestorage-core    Within a subcomponent's subfolder, create a source code hierarchy following the pattern  src/main/scala/de/kaufhof/ets/<component-name>/<subcomponent-name> , e.g.  src/main/scala/de/kaufhof/ets/filestorage/core    Component and subcomponent namespace segments must be one-word all-lowercase UTF-8  [a-z0-9]  strings (e.g.  de.kaufhof.ets.filestorage.core )    Component artifactIds must be at-least-one-word, possibly multiple-words-concatenated-by-hyphens all-lowercase UTF-8  [a-z0-9]  strings (e.g.  ets-filestorage-core )",
            "title": "Naming and namespacing rules"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/rules/#example",
            "text": "The source code for an ETS-compatible filestorage library would live at  https://github.com/Galeria-Kaufhof/ets-filestorage .  Its groupId + artifactId name would be  de.kaufhof.ets:ets-filestorage-core .  The Scala source code tree starts at  /ets-filestorage-core/src/main/scala/de/kaufhof/ets/filestorage/core , with package names starting with  de.kaufhof.ets.filestorage.core .",
            "title": "Example"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/versioning/",
            "text": "Versioning\n\n\nThis document describes how different versions of ETS component source codes and artifacts are managed, declared, structured and used within the development and release lifecycle of a component.\n\n\nETS core and components versioning relationships\n\n\nWhile there is no single central \"ETS application\" which is maintained and released in an integrated and central fashion, we nevertheless handle the offical ETS ecosystem as one connected construct, and version accordingly.\n\n\nTo do so, we define major ETS releases following the SemVer schema, thus subsuming ETS core components and ETS libraries under the same major version number for each release.\n\n\nThe result is a collection of components with publicly artifacts, where artifacts that share the same major version number are guaranteed to be compatible with each other.\n\n\nThus, for example, the \"ETS version 1 release\" is the collection of all 1.x.x versions of the different ETS components.\n\n\nBecause there is no central ETS artifact, releases of the general ETS ecosystem are not specified using a \nmajor.minor.patch\n schema. Instead, the concrete state of an \"ETS version 1 release\" is in constant flux - at a given point in time, it could be a collection of \nets-elasticsearch-rest-connector 1.4.3\n, \nets-filestorage 1.2.0\n, and \nets-akka-stream-utils 1.9.5\n, and choosing from a subset of these components as a basis for your \"ETS version 1\"-based application is legit and safe in terms of interoperability of the components - as long as you don't \"pin\" your dependency definitions to a specific version of an ETS component, and instead use a range definition (\n[1.0.0,2)\n).\n\n\nGit branching and tagging\n\n\nAll ETS component git repositories follow these rules:\n\n\n\n\nAs soon as the first major non-0.x.x version of a component is released, the git repository must have a tag named \n<current-major>.0.0\n which points to the commit with which the release milestone was reached\n\n\nAs soon as the first major non-0.x.x version of a component is released, the git repository must have a branch named \n<current-major>.x.x\n whose tip points to the latest version of the code within the current major version\n\n\nWhenever new minor/patch versions are released within a major release, \n<major>.<minor>.<patch>\n tags must be created accordingly\n\n\nThe latest version of the upcoming but not yet released minor/patch version of a released major version is developed in the \n<major>.x.x\n branch\n\n\nMeanwhile, the latest version of the upcoming but not yet released \n<current-major + 1>\n version of the component is developed in the \nmaster\n branch\n\n\nAs soon as a new major version (= \n<current-major + 1>\n) is released, a tag named \n<current-major + 1>.0.0\n and a new branch \n<current-major + 1>.0.0\n must be created\n\n\nThus, \n<current-major + 1>\n becomes the new \n<current-major>\n\n\nAgain, the latest version of the upcoming but not yet released \n<current-major+1>\n version of the component is developed in the \nmaster\n branch\n\n\n\n\nExample:\n\n\nLet's assume that ETS has already been released in versions \n1\n and \n2\n, and work on a version \n3\n release is ongoing. In this case, the git branch and tag structure of a hypothetical ETS component \nets-foo-connector\n might look as follows:\n\n\n\n\nA branch \nmaster\n exists, containing the current work that is underway to prepare release \nets-foo-connector 3.0.0\n for the upcoming ETS version 3 release\n\n\nA branch \n1.x.x\n exists, because \nets-foo-connector\n was part of the ETS version 1 release; it contains the latest code for this major version, up to and including a couple of not-yet-released changes for a bugfix that will be released as \nets-foo-connector 1.2.1\n\n\nThe tags \n1.0.0\n, \n1.2.0\n, and \n1.3.0\n exist. They all point to commits that are also included within the commit history of branch \n1.x.x\n, and mark the different minor versions that this component released within the ETS version 1 release\n\n\nA branch \n2.x.x\n exists, because \nets-foo-connector\n was part of the ETS version 2 release\n\n\nOnly the tag \n2.0.0\n exists, because after the initial 2.x.x release, the project did not release any new versions under the ETS version 2 release",
            "title": "Versioning"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/versioning/#versioning",
            "text": "This document describes how different versions of ETS component source codes and artifacts are managed, declared, structured and used within the development and release lifecycle of a component.",
            "title": "Versioning"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/versioning/#ets-core-and-components-versioning-relationships",
            "text": "While there is no single central \"ETS application\" which is maintained and released in an integrated and central fashion, we nevertheless handle the offical ETS ecosystem as one connected construct, and version accordingly.  To do so, we define major ETS releases following the SemVer schema, thus subsuming ETS core components and ETS libraries under the same major version number for each release.  The result is a collection of components with publicly artifacts, where artifacts that share the same major version number are guaranteed to be compatible with each other.  Thus, for example, the \"ETS version 1 release\" is the collection of all 1.x.x versions of the different ETS components.  Because there is no central ETS artifact, releases of the general ETS ecosystem are not specified using a  major.minor.patch  schema. Instead, the concrete state of an \"ETS version 1 release\" is in constant flux - at a given point in time, it could be a collection of  ets-elasticsearch-rest-connector 1.4.3 ,  ets-filestorage 1.2.0 , and  ets-akka-stream-utils 1.9.5 , and choosing from a subset of these components as a basis for your \"ETS version 1\"-based application is legit and safe in terms of interoperability of the components - as long as you don't \"pin\" your dependency definitions to a specific version of an ETS component, and instead use a range definition ( [1.0.0,2) ).",
            "title": "ETS core and components versioning relationships"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/versioning/#git-branching-and-tagging",
            "text": "All ETS component git repositories follow these rules:   As soon as the first major non-0.x.x version of a component is released, the git repository must have a tag named  <current-major>.0.0  which points to the commit with which the release milestone was reached  As soon as the first major non-0.x.x version of a component is released, the git repository must have a branch named  <current-major>.x.x  whose tip points to the latest version of the code within the current major version  Whenever new minor/patch versions are released within a major release,  <major>.<minor>.<patch>  tags must be created accordingly  The latest version of the upcoming but not yet released minor/patch version of a released major version is developed in the  <major>.x.x  branch  Meanwhile, the latest version of the upcoming but not yet released  <current-major + 1>  version of the component is developed in the  master  branch  As soon as a new major version (=  <current-major + 1> ) is released, a tag named  <current-major + 1>.0.0  and a new branch  <current-major + 1>.0.0  must be created  Thus,  <current-major + 1>  becomes the new  <current-major>  Again, the latest version of the upcoming but not yet released  <current-major+1>  version of the component is developed in the  master  branch",
            "title": "Git branching and tagging"
        },
        {
            "location": "/Contributing-to-and-maintaining-ETS/versioning/#example",
            "text": "Let's assume that ETS has already been released in versions  1  and  2 , and work on a version  3  release is ongoing. In this case, the git branch and tag structure of a hypothetical ETS component  ets-foo-connector  might look as follows:   A branch  master  exists, containing the current work that is underway to prepare release  ets-foo-connector 3.0.0  for the upcoming ETS version 3 release  A branch  1.x.x  exists, because  ets-foo-connector  was part of the ETS version 1 release; it contains the latest code for this major version, up to and including a couple of not-yet-released changes for a bugfix that will be released as  ets-foo-connector 1.2.1  The tags  1.0.0 ,  1.2.0 , and  1.3.0  exist. They all point to commits that are also included within the commit history of branch  1.x.x , and mark the different minor versions that this component released within the ETS version 1 release  A branch  2.x.x  exists, because  ets-foo-connector  was part of the ETS version 2 release  Only the tag  2.0.0  exists, because after the initial 2.x.x release, the project did not release any new versions under the ETS version 2 release",
            "title": "Example:"
        },
        {
            "location": "/Using-ETS/archetypes/",
            "text": "",
            "title": "Archetypes"
        },
        {
            "location": "/Using-ETS/building-applications/",
            "text": "",
            "title": "Building applications"
        },
        {
            "location": "/libraries/Akka-Stream-Utils/",
            "text": "",
            "title": "Home"
        },
        {
            "location": "/libraries/ElasticSearch-REST-Connector/",
            "text": "ElasticSearch REST Connector\n\n\nTable of contents\n\n\n\n\nIndexing",
            "title": "ElasticSearch REST Connector"
        },
        {
            "location": "/libraries/ElasticSearch-REST-Connector/#elasticsearch-rest-connector",
            "text": "",
            "title": "ElasticSearch REST Connector"
        },
        {
            "location": "/libraries/ElasticSearch-REST-Connector/#table-of-contents",
            "text": "Indexing",
            "title": "Table of contents"
        },
        {
            "location": "/libraries/ElasticSearch-REST-Connector/indexing/",
            "text": "Indexing\n\n\nCreate an index\n\n\nBased on this documentation. For now, it is only implemented that you can create an index with a \nMappingobject\n or a \nJson-Object\n.\n\n\nelasticClient.createIndex(INDEXNAME, MAPPINGOBJECT): Future[ElasticIndexCreateResult]\n\n\n\nEach \ncreateIndex\n resulted in a \nscala.concurrent.Future[ElasticIndexCreateResult]\n with the following \nReturnParameter\n:\n\n\nElasticIndexCreateResult.created[Boolean]\nElasticIndexCreateResult.throwable[Option[Throwable]]\n\n\n\nIf the \ncreateIndex\n resulted without errors, \n.throwable\n is \nNone\n, if not, \n.throwable\n is filled as \nSome(throwable)\n with the underlying exception.",
            "title": "Indexing"
        },
        {
            "location": "/libraries/ElasticSearch-REST-Connector/indexing/#indexing",
            "text": "",
            "title": "Indexing"
        },
        {
            "location": "/libraries/ElasticSearch-REST-Connector/indexing/#create-an-index",
            "text": "Based on this documentation. For now, it is only implemented that you can create an index with a  Mappingobject  or a  Json-Object .  elasticClient.createIndex(INDEXNAME, MAPPINGOBJECT): Future[ElasticIndexCreateResult]  Each  createIndex  resulted in a  scala.concurrent.Future[ElasticIndexCreateResult]  with the following  ReturnParameter :  ElasticIndexCreateResult.created[Boolean]\nElasticIndexCreateResult.throwable[Option[Throwable]]  If the  createIndex  resulted without errors,  .throwable  is  None , if not,  .throwable  is filled as  Some(throwable)  with the underlying exception.",
            "title": "Create an index"
        },
        {
            "location": "/libraries/Filestorage/",
            "text": "",
            "title": "Home"
        }
    ]
}